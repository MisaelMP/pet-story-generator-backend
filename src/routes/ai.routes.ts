import { Router, Request, Response } from 'express';
import {
	storyRequestSchema,
	StoryRequest,
	APIError,
	StoryResponse,
	storyResponseSchema,
} from '../types';
import { OpenAIService } from '../services/openai.service';
import { XanoService } from '../services/xano.service';
import { aiRateLimit } from '../middleware/security';

const router = Router();

// Apply rate limiting to all AI routes
router.use(aiRateLimit);

// Generate story endpoint
router.post(
	'/generate-story',
	async (req: Request, res: Response): Promise<void> => {
		try {
			// Validate request
			const validatedData: StoryRequest = storyRequestSchema.parse(req.body);

			console.log('Story generation request:', {
				promptLength: validatedData.prompt.length,
				petId: validatedData.options.petId,
				saveToXano: validatedData.options.saveToXano,
			});

			// Content moderation check
			if (validatedData.options.moderationCheck) {
				const isFlagged = await OpenAIService.moderateContent(
					validatedData.prompt
				);

				if (isFlagged) {
					const error: APIError = {
						error: 'Content violates usage policies',
						message: 'Please revise your content and try again',
					};
					res.status(400).json(error);
					return;
				}
			}

			// Generate story with OpenAI
			const completion = await OpenAIService.generateStory(
				validatedData.prompt,
				validatedData.parameters
			);

			const content = completion.choices[0]?.message?.content;
			if (!content) {
				throw new Error('No content generated by AI');
			}

			// Handle response - try JSON first, fallback to plain text
			let responseData: StoryResponse;

			try {
				// Try to parse as JSON first
				const parsedContent = JSON.parse(content);
				responseData = storyResponseSchema.parse(parsedContent);
			} catch (parseError) {
				// Fallback: treat as plain text story
				console.log('AI returned plain text, treating as story content');
				responseData = storyResponseSchema.parse({
					content: content,
				});
			}

			// Save to Xano if requested and configured
			let savedToXano = false;
			if (
				validatedData.options.saveToXano &&
				validatedData.options.petId &&
				XanoService.isConfigured()
			) {
				try {
					await XanoService.saveStory({
						pims_pet_id: validatedData.options.petId,
						title: responseData.title,
						content: responseData.content,
						tone: responseData.tone,
						suggested_goal: responseData.suggestedGoal,
						key_points: responseData.keyPoints,
						form_data: validatedData.options.formData || {},
					});
					savedToXano = true;
				} catch (xanoError) {
					console.error('Xano save failed (non-blocking):', xanoError);
					// Don't fail the request if Xano save fails
				}
			}

			// Log successful generation
			console.log('Story generated successfully:', {
				model: completion.model,
				tokens: completion.usage?.total_tokens,
				savedToXano,
			});

			// Return response
			res.json({
				story: responseData,
				usage: completion.usage,
				model: completion.model,
				savedToXano,
				timestamp: new Date().toISOString(),
			});
			return;
		} catch (error) {
			console.error('Story generation error:', error);

			// Handle validation errors
			if (error instanceof Error && error.name === 'ZodError') {
				const apiError: APIError = {
					error: 'Invalid request format',
					message: 'Please check your request parameters',
					details: error.message,
				};
				res.status(400).json(apiError);
				return;
			}

			// Handle other errors
			const apiError: APIError = {
				error: 'Story generation failed',
				message:
					process.env.NODE_ENV === 'development'
						? error instanceof Error
							? error.message
							: 'Unknown error'
						: 'Internal server error',
			};

			res.status(500).json(apiError);
			return;
		}
	}
);

export default router;
